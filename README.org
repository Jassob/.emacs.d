# -*- indent-tabs-mode: nil; -*-
#+TITLE: Jassob's Emacs configuration
#+DATE: <2018-01-19 Fri>

* TODO Steal some kind of module system
  I want to be able to fire up a lightweight version of my emacs
  config that only includes a specific set of modules to speed up
  start up time.

* About this file
  This file contains my configurations for Emacs.

  Very much inspired by [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua's Emacs Configuration]], with some
  stolen bits and pieces from both [[http://spacemacs.org][Spacemacs]]/[[https://github.com/TheBB/spaceline][Spaceline]] and [[https://github.com/hlissner/.emacs.d][hlissner's
  Emacs config]].

  This file generates my config by tangling all source code blocks in
  the text to a single elisp-file.

  To make use of my config you need to have Emacs with org-mode
  installed, open this file and run the function ~org-babel-tangle~,
  which by default is bound to =C-c C-v t=.

* Emacs initialisation
** System directories

   I don't like keeping a lot of files visible in my =.emacs.d=
   directory, so let's create a directory hierarchy for all files that
   I'm not interested in.

   #+name: sys-dir-init
   #+begin_src emacs-lisp :tangle init.el
     (defvar local-dir (concat user-emacs-directory ".local/")
       "Root directory for local Emacs files. Use this as
       permanent storage for files that are safe to share across
       systems (if this config is symlinked across several computers).")

     (defvar etc-dir (concat local-dir "@" (system-name) "/etc/")
       "Host-namespaced directory for non-volatile storage. These are not deleted or
       tampored with by DOOM functions. Use this for dependencies like servers or
       config files that are stable (i.e. it should be unlikely that you need to delete
       them if something goes wrong).")

     (defvar cache-dir (concat local-dir "@" (system-name) "/cache/")
       "Host-namespaced directory for volatile storage. Deleted
       when `local/clean-cache' is called. Use this for transient files
       that are generated on the fly like caches and temporary
       files. Anything that may need to be cleared if there are
       problems.")

     (defvar packages-dir (concat local-dir "packages/")
       "Where package.el packages and cache are stored.")

     (defvar include-dir (concat user-emacs-directory "include/")
       "Where we store stuff that's not part of emacs packages or
         other dependencies.")

   #+end_src

   We need to make sure that the directories are created before we try
   to make Emacs store stuff there.

   #+name: create-sys-dir
   #+begin_src emacs-lisp :tangle init.el
     (dolist (dir (list local-dir etc-dir cache-dir packages-dir include-dir))
       (unless (file-exists-p dir)
         (make-directory dir t)))
   #+end_src

   We might want to clear the local cache, here is a command for doing
   that.

   #+begin_src emacs-lisp :tangle init.el
     (defun local/clean-cache()
       "Clears local cache (`local-dir') directory. You may need to
     restart Emacs for some components to feel its effects."
       (interactive)
       (delete-directory cache-dir t)
       (make-directory cache-dir t))
   #+end_src

   We might want to read and store values to/from a file, these
   routines lets us store Emacs lisp values and then retrieve them.

   #+name: file-help-funs
   #+begin_src emacs-lisp :tangle init.el
     (defun print-to-file (filename data)
       "Create FILENAME and store DATA inside it."
       (with-temp-file filename
         (prin1 data (current-buffer))))

     (defun read-from-file (filename)
       "Read Emacs Lisp variables from FILENAME."
       (with-temp-buffer
         (insert-file-contents filename)
         (cl-assert (eq (point) (point-min)))
         (read (current-buffer))))
   #+end_src

   Sometimes updating config files and creating them if they don't
   exist is a common operation, such as activating a mode for the
   first time.

   #+name: local-alist-funs
   #+begin_src emacs-lisp :tangle init.el
     (defun local--update-alist-file (file val)
       "Update FILE with value VAL.
     If FILE exists VAL will be appended to it's variable,
     otherwise VAL will be stored in a new file FILE."
       (if (file-exists-p file)
           (let ((alist (read-from-file file)))
             (add-to-list 'alist val)
             (print-to-file file alist))
         (print-to-file file val)))

     (defun local--init-file-if-missing (file init-fn)
       "Check if FILE exists and if not it creates it and initializes
      it with the unary function INIT-FN."
       (unless (file-exists-p file)
         (print-to-file file (list (funcall init-fn)))))
   #+end_src

** System files and backups

   Emacs stores backups of the file you are working on in the current
   directory by default and while backups are great I prefer keeping
   them in the directories defined above.

   So, lets store all backups in the local directory!

   #+name: set-backup-directory-alist
   #+begin_src emacs-lisp :tangle init.el
     (setq backup-directory-alist `((".*" . ,(concat local-dir "backups"))))
   #+end_src

   Also, we'd like to store versioned backups and also make sure to
   backup files that is under version control (in case we forget to
   commit every interesting change).

   #+name: backup-settings
   #+begin_src emacs-lisp :tangle init.el
     (setq delete-old-versions -1
           version-control t
           vc-make-backup-files t)
   #+end_src

   Emacs auto-saving feature can be a life saver, let's put those
   files where we want them instead of having them in the emacs root
   directory.

   #+name: auto-save-settings
   #+begin_src emacs-lisp :tangle init.el
     (let ((auto-save-dir (concat cache-dir "auto-save-list/")))
       ;; Create directory
       (unless (file-exists-p auto-save-dir)
         (make-directory auto-save-dir t))

       ;; Store auto-saves in the newly created directory
       (setq auto-save-file-name-transforms `((".*" ,auto-save-dir t))
             auto-save-list-file-prefix auto-save-dir))

   #+end_src

   Similar to backups I dont like my bookmarks to litter in the config
   directory, so we put them in =cache-dir= with everything else.
   Also EWW stores it's own bookmarks in a file that by default exists
   in Emacs dir.

   #+begin_src emacs-lisp :tangle init.el
     (setq bookmark-default-file (concat etc-dir "bookmarks")
           eww-bookmark-directory etc-dir)
   #+end_src

   The Emacs Shell (eshell) is very nice to use since it integrates
   the shell experience well with Emacs, but it too litters my Emacs
   directory by default, please don't!

   #+begin_src emacs-lisp :tangle init.el
     (setq eshell-directory-name (concat etc-dir "eshell"))
   #+end_src

   I don't use Gnus yet, but the ambition is there. It stores a cache
   that by default not lives in the Emacs directory, but in my home
   directory(!) which is even worse.

   #+begin_src emacs-lisp :tangle init.el
     (setq gnus-cache-directory (concat cache-dir "news")
           gnus-directory       (concat local-dir "news")
           gnus-kill-files-directory (concat local-dir "news"))
   #+end_src

   Url package files are also stored in the Emacs directory, move them
   to the local-dir and its' sub directories.

   #+begin_src emacs-lisp :tangle init.el
     (setq url-cache-directory (concat cache-dir "url")
           url-configuration-directory (concat etc-dir "url"))
   #+end_src

   I also don't like to keep my diary file nor the journal folder in
   the Emacs directory.

   #+begin_src emacs-lisp :tangle init.el
     (setq diary-file (concat local-dir "diary")
           org-journal-dir (concat local-dir "journal/"))
   #+end_src

   TRAMP is a wonderful way to edit files that does not exist on this
   machine or that is not writable by your user. It can write to files
   over SSH, rlogin or Telnet and can also be used to edit write local
   protected files using sudo.

   #+name: tramp-dir-settings
   #+begin_src emacs-lisp :tangle init.el
     (setq tramp-backup-directory-alist backup-directory-alist
           tramp-persistency-file-name (concat cache-dir "tramp")
           tramp-default-method        "ssh")

   #+end_src

   When I edit system configuration files I might accidentally find
   files as my regular user, even though I need sudo rights to edit
   them. This advice makes =ido-find-file= automatically open it
   through =TRAMP= as sudo if it is not writable by my user.

   #+name: tramp-sudo-edit
   #+begin_src emacs-lisp :tangle init.el
     (defadvice ido-find-file (after find-file-sudo activate)
       "Find file as root if necessary."
       (when (and buffer-file-name
                  (not (file-writable-p buffer-file-name))
                  (y-or-n-p "Do you want to edit as sudo?"))
         (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))
   #+end_src

** Packages

   First we need to activate the package system and add the melpa
   repository, if it is not already added.

   #+name: package/settings
   #+begin_src emacs-lisp :tangle init.el
      (require 'package)
      (setq package-user-dir (expand-file-name "elpa" packages-dir)
            package-archives '(("gnu"   . "https://elpa.gnu.org/packages/")
                               ("melpa" . "https://melpa.org/packages/")))
      (package-initialize)

      ;; We've already enabled the package system.
      (setq package-enable-at-startup nil)
   #+end_src

   Make sure to reload the list of packages by calling =M-x
   package-refresh-contents= when adding melpa for the first time.

** use-package

   I use =use-package= for keeping track of my packages, customising them
   and load them lazily.

   #+name: package/use-package
   #+begin_src emacs-lisp :tangle init.el
     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))
     (setq use-package-verbose t)
   #+end_src

** Secrets and custom settings

   I store more sensitive data in =~/.emacs.d/.local/.secrets= and
   customized settings in
   =~/.emacs.d/.local/@host-name/etc/custom-settings.el= so I easily
   can store my main configuration in a public version control system.

   #+begin_src emacs-lisp :tangle init.el
     (load "~/.emacs.d/.local/.secrets" t)

     (setq custom-file (concat etc-dir "custom-settings.el"))
     (load custom-file t)
   #+end_src

* Personal customization

  Give my setup a personal touch.

  #+name: identity-stuff
  #+begin_src emacs-lisp :tangle init.el
     (setq user-full-name "Jacob Jonsson"
       user-mail-address "jacob.t.jonsson@gmail.com")
  #+end_src

  I don't like to type more than necessary, so why do I need to type
  1-2 extra letters when the first letter is enough?

  #+begin_src emacs-lisp :tangle init.el
     (fset 'yes-or-no-p 'y-or-n-p)
  #+end_src

  I've seen the splash screen enough times now, please don't show it
  to me anymore.

  #+name: hide-splash-screen
  #+begin_src emacs-lisp :tangle init.el
     (setq inhibit-splash-screen t)
  #+end_src

  Even though the standard Emacs interactive
  execute-extended-command works in most cases I personally prefer
  =smex= and use more Ido features.

  #+name: package/smex
  #+begin_src emacs-lisp :tangle init.el
     (use-package smex :ensure t :demand t
       :config
       (setq ido-everywhere t
             ido-enable-flex-matching t
             ido-create-new-buffer t
             ido-save-directory-list-file (concat cache-dir "ido.last")
             smex-save-file (concat cache-dir "smex-items"))
       (ido-mode t)
       :bind ("M-x" . smex))
  #+end_src

  I'd like to keep a list of my recently visited files and =recentf=
  helps me do that.

  #+name: package/recentf
  #+begin_src emacs-lisp :tangle init.el
     (use-package recentf
       :config
       (setq recentf-save-file (concat cache-dir "recentf"))

       (defun recentf-ido-find-file ()
         "Find a recent file using Ido."
         (interactive)
         (let ((file (ido-completing-read "Choose recent file: " recentf-list nil t)))
           (when file
             (find-file file))))

       :bind ("C-x C-r" . recentf-ido-find-file))
  #+end_src

  To help me remember my commands I use =guide-key=, which displays a
  popup showing all the keybindings belonging to a prefix key.

  #+name: package/guide-key
  #+begin_src emacs-lisp :tangle init.el
     (use-package guide-key :diminish t
       :ensure t :config
       (setq guide-key/guide-key-sequence t
             guide-key/popup-window-position 'bottom
             guide-key/highlight-command-regexp ".*")
       (guide-key-mode t))
  #+end_src

  Now that I'm trying out Dvorak (Svorak A5) these changes makes the
  transition between key layouts easier.

  #+name: dvorak-bindings
  #+begin_src emacs-lisp :tangle init.el
    ;; Bind C-z to C-x
    (global-set-key (kbd "C-z") ctl-x-map)

    ;; Bind C-h to previous-line since C-p is no longer on the same half
    ;; of the keyboard
    (global-set-key (kbd "C-x C-h") help-map)
    (global-set-key (kbd "C-h") 'previous-line)
  #+end_src

** Commands for local keymap

   This is a command for finding the init file, for the times I need
   to quickly edit my config for some reason. A command for editing
   and untangling the org file.

   #+name: local-keymap-functions
   #+begin_src emacs-lisp :tangle init.el
     (defun local--find-init-file ()
       "Find the init file."
       (interactive)
       (find-file (concat user-emacs-directory "init.el")))

     (defun local--find-org-file ()
       "Find the org file."
       (interactive)
       (find-file (concat user-emacs-directory "README.org")))

     (defun local--untangle-file ()
       "Run org-babel-tangle on the org file, updating the init file."
       (interactive)
       (org-babel-tangle-file (concat user-emacs-directory "README.org")))

     (defun local--eval-init-file ()
       "Evaluate the init file again to refresh Emacs."
       (interactive)
       (progn
         (local--untangle-file)
         (load-file (concat user-emacs-directory "init.el"))))
   #+end_src

   I have defined a keymap for commands that I'd like to execute as if
   they were defined in global keymap.

   #+name: local-keymap
   #+begin_src emacs-lisp :tangle init.el
     (bind-keys :prefix-map my-local-map
                :prefix "M--"
                :prefix-docstring "Commands I like to access quicker than through M-x"
                ("g" . magit-status))


     (bind-keys :prefix-map my-local-project-map
                :prefix "M-- p"
                :prefix-docstring "Project related commands"
                ("d" . projectile-dired)
                ("b" . projectile-switch-to-buffer)
                ("p" . projectile-switch-project))

     (bind-keys :prefix-map my-local-config-map
                :prefix "M-- c"
                :prefix-docstring "Config related commands"
                ("f" . local--find-init-file)
                ("s" . local--find-org-file)
                ("t" . local--untangle-file)
                ("e" . local--eval-init-file))
   #+end_src

* General configuration
** Undo tree mode

   I find Emacs default undo behaviour rather intuitive (of course a
   redo is just an undo of your last undo!), but I like being able to
   visualise the timeline of my file. Enters =undo-tree-mode=!

   #+name: package/undo-tree
   #+begin_src emacs-lisp :tangle init.el
      (use-package undo-tree
        :ensure t :diminish t
        :config
        (global-undo-tree-mode)
        (setq undo-tree-visualizer-timestamps t)
        (setq undo-tree-visualizer-diff t))
   #+end_src

** UTF8

   We would like Emacs to prefer UTF8 when reading ambiguous bit
   strings.

   #+name: utf8
   #+begin_src emacs-lisp :tangle init.el
     (prefer-coding-system 'utf-8)
     (when (display-graphic-p)
       (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
   #+end_src

* External programs

  There are sometimes when I need to interact with external programs.
  For instance I sometimes like to open URL's in a more capable
  browser than EWW (even though it is very good!).

  Firefox is currently my driver of choice.

  #+name: external-programs
  #+begin_src emacs-lisp :tangle init.el
    (setq browse-url-browser-function 'browse-url-firefox
          browse-url-new-window-flag  t)
  #+end_src

* Editor
** Cursors

   When one has gotten used to multiple cursors it is hard to live
   without. Luckily there exists an aptly named package that solves
   this use case.

   #+name: package/multiple-cursors
   #+begin_src emacs-lisp :tangle init.el
     (use-package multiple-cursors :ensure t
       :init
       (setq mc/list-file (concat cache-dir ".mc-lists.el"))
       :bind (("C-S-c C-S-c" . mc/edit-lines)
              ("C->" . mc/mark-next-like-this)     ;; C-> for the next word
              ("C-<" . mc/mark-previous-like-this) ;; C-< for the previous
              ("C-c C->" . mc/mark-all-like-this))) ;; C-c C-> for all words
   #+end_src

** Buffer and window navigation

   Switching between windows can be a bit of a pain, just cycling
   through them with =C-x o= is not really good enough. I therefore
   use ~windmove~ and ~buffer-move~ to navigate amongst my buffers and
   I have them bound to, in my opinion at least, sensible keybindings.

   #+name: windmove-keybindings
   #+begin_src emacs-lisp :tangle init.el
     (bind-keys ("<S-s-left>"  . windmove-left)
                ("<S-s-up>"    . windmove-up)
                ("<S-s-down>"  . windmove-down)
                ("<S-s-right>" . windmove-right))
   #+end_src

   With ~buffer-move~ I can move around buffers and swap them around
   on the screen with ease.

   #+name: buf-move-keybindings
   #+begin_src emacs-lisp :tangle init.el
     (use-package buffer-move :ensure t
       :bind (("C-c <left>"  . buf-move-left)
              ("C-c <right>" . buf-move-right)
              ("C-c <down>"  . buf-move-down)
              ("C-c <up>"    . buf-move-up)))
   #+end_src

   Sometimes it is nice to be able to shrink and enlarge windows
   easily and that is why I've bounded them to simple keys:

   #+name: resize-window-keybindings
   #+begin_src emacs-lisp :tangle init.el
     (bind-keys ("S-C-<left>"  . shrink-window-horizontally)
                ("S-C-<right>" . enlarge-window-horizontally)
                ("S-C-<down>"  . shrink-window)
                ("S-C-<up>"    . enlarge-window))
   #+end_src

** Visual appearance

   It is great that you can start out learning Emacs like a normal
   person, using the mouse and navigating through the menu and tool
   bar. However, on a smaller screen I find it a waste of screen
   space (especially since I don't use the mouse myself).

   #+name: toolbar-settings
   #+begin_src emacs-lisp :tangle init.el
     (tool-bar-mode -1)
     (menu-bar-mode -1)
     (scroll-bar-mode -1)
   #+end_src

   I really like the =sanity-tomorrow-night= theme. It's a dark theme
   with good contrast and stuff.

   #+name: theme-settings
   #+begin_src emacs-lisp :tangle init.el
     (unless (package-installed-p 'color-theme-sanityinc-tomorrow)
       (package-install 'color-theme-sanityinc-tomorrow))

     (load-theme 'sanityinc-tomorrow-night t)
   #+end_src

   The fonts in =font-preferences= are the preferred fonts that I use
   on my system, in descending order. The first font that is available
   will be set as the main font for Emacs.

   #+name: font-settings
   #+begin_src emacs-lisp :tangle init.el
          (use-package cl-lib :ensure t)
          (defun font-existsp (font)
            "Check to see if the named FONT is available."
            (if (null (x-list-fonts font)) nil t))

          (defun font-avail (fonts)
            "Finds the available fonts."
            (cl-remove-if-not 'font-existsp fonts))

          (defvar font-preferences
            '( "Hasklig"
               "Inconsolata"
               "Fira Code"
               "Source Code Pro"
               "PragmataPro"))

          (unless (eq window-system nil)
            (let ((fonts (font-avail font-preferences)))
              (unless (null fonts) (progn
                  (set-face-attribute 'default nil :font (car fonts))
                  (set-face-attribute 'default nil :weight 'medium)))))
   #+end_src

   #+name: ligature-settings
   #+begin_src emacs-lisp :tangle init.el
     (defun my-correct-symbol-bounds (pretty-alist)
       "Prepend a TAB character to each symbol in this alist,
     this way compose-region called by prettify-symbols-mode
     will use the correct width of the symbols
     instead of the width measured by char-width."
       (mapcar (lambda (el)
                 (setcdr el (string ?\t (cdr el)))
                 el)
               pretty-alist))

     (defun my-ligature-list (ligatures codepoint-start)
       "Create an alist of strings to replace with
     codepoints starting from codepoint-start."
       (let ((codepoints (-iterate '1+ codepoint-start (length ligatures))))
         (-zip-pair ligatures codepoints)))

     ;; list can be found at https://github.com/i-tu/Hasklig/blob/master/GlyphOrderAndAliasDB#L1588
     (setq my-hasklig-ligatures
           (let* ((ligs '("&&" "***" "*>" "\\\\" "||" "|>" "::"
                          "==" "===" "==>" "=>" "=<<" "!!" ">>"
                          ">>=" ">>>" ">>-" ">-" "->" "-<" "-<<"
                          "<*" "<*>" "<|" "<|>" "<$>" "<>" "<-"
                          "<<" "<<<" "<+>" ".." "..." "++" "+++"
                          "/=" ":::" ">=>" "->>" "<=>" "<=<" "<->")))
             (my-correct-symbol-bounds (my-ligature-list ligs #Xe100))))

     ;; nice glyphs for haskell with hasklig
     (defun my-set-hasklig-ligatures ()
       "Add hasklig ligatures for use with prettify-symbols-mode."
       (setq prettify-symbols-alist
             (append my-hasklig-ligatures prettify-symbols-alist))
       (prettify-symbols-mode))
   #+end_src

** Move to beginning of line

   [[http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line][Source]]

   The default behaviour of calling =C-a= is to jump directly to the
   beginning of the line, although we probably would like to go to
   the beginning of the text on the line (and skip all the
   indentation whitespace).

   #+name: move-to-start-of-line
   #+begin_src emacs-lisp :tangle init.el
     (defun local/smarter-move-beginning-of-line (arg)
       "Move point back to indentation of beginning of line.

        Move point to the first non-whitespace character on this line.
        If point is already there, move to the beginning of the line.
        Effectively toggle between the first non-whitespace character and
        the beginning of the line.

        If ARG is not nil or 1, move forward ARG - 1 lines first.  If
        point reaches the beginning or end of the buffer, stop there."
        (interactive "^p")
        (setq arg (or arg 1))

        ;; Move lines first
        (when (/= arg 1)
          (let ((line-move-visual nil))
            (forward-line (1- arg))))

        (let ((orig-point (point)))
          (back-to-indentation)
          (when (= orig-point (point))
            (move-beginning-of-line 1))))

     ;; remap C-a to smarter-move-beginning-of-line
     (global-set-key [remap move-beginning-of-line]
                     'local/smarter-move-beginning-of-line)
   #+end_src

** Version control

   I mostly use [[https://git-scm.com/][Git]] to handle my version control and while it
   certainly got somewhat of a steep learning curve and a few rough
   edges here and there I mostly find it intuitive.

   To help me manage my Git repositories I use the fantastic package
   =magit=, which is a Git frontend to Emacs and one of the few Git
   frontends I really like.

   #+name: package/magit
   #+begin_src emacs-lisp :tangle init.el
     (use-package magit :ensure t :defer t)
   #+end_src

   =Git-gutter+= is a package that shows a line's status (added,
   modifid or deleted) in a file that is version controlled by Git.

   #+name: package/git-gutter+
   #+begin_src emacs-lisp :tangle init.el
     (use-package git-gutter+ :ensure t :defer t :diminish t
       :bind (:map git-gutter+-mode-map
                   ;; Navigate on hunks
                   ("C-x n"   . git-gutter+-next-hunk)
                   ("C-x p"   . git-gutter+-previous-hunk)
                   ;; Act on hunks
                   ("C-x v =" . git-gutter+-show-hunk)
                   ("C-x r"   . git-gutter+-revert-hunks)
                   ("C-x t"   . git-gutter+-stage-hunks)
                   ("C-x c"   . git-gutter+-commit)
                   ("C-x C"   . git-gutter+-stage-and-commit)
                   ("C-x C-y" . git-gutter+-stage-and-commit-whole-buffer)
                   ("C-x U"   . git-gutter+-unstage-whole-buffer)))
   #+end_src

   To help me interact with my Github repositories I use =magithub=.

   #+name: package/magithub
   #+begin_src emacs-lisp :tangle init.el
     (use-package magithub :after magit
       :init (defvar magithub--auth-file (concat etc-dir "magithub-auth-file"))
       :config
       (magithub-feature-autoinject t)
       (local--init-file-if-missing magithub--auth-file
                                    #'magithub--prompt-for-auth)
       (magithub--import-auth-file)
       (setq magithub-dir (concat cache-dir "magithub")))

     (defun magithub--import-auth-file ()
       "Import magithub credentials from =magit-auth-file= in =etc-dir=.
     The file must only contain a alist with the following keys:
     \(
      (ghub-base-url . VAL)
      (ghub-username . VAL)
      (ghub-token    . VAL)
     \)"
       (if (file-exists-p magithub--auth-file)
           (let-alist (read-from-file magithub--auth-file)
             (progn
               (setq ghub-base-url .ghub-base-url)
               (setq ghub-username .ghub-username)
               (setq ghub-token    .ghub-token)))
         (warn (concat "magithub: Could not find file: " magithub--auth-file))))
   #+end_src

   I store the authentication files in the =etc-dir= and to ease the
   setup of this customization I have a function that fills this files
   with the needed data.

   #+name: magithub-auth-settings
   #+begin_src emacs-lisp :tangle init.el
     (defun magithub--prompt-for-auth ()
       "Prompts the user for magithub credentials."
       (let ((res (make-local-variable 'auth-alist)))
         (setq-local auth-alist ())
         (dolist (key '((ghub-base-url . "Github base URL: ")
                        (ghub-username . "Github username: ")
                        (ghub-token . "Github token: ")))
           (add-to-list 'auth-alist (cons (car key)
                                          (read-from-minibuffer (cdr key)))))
         ;; Return the result
         auth-alist))

     (defun magithub--set-auth-info ()
       "Prompts the user for credentials for magithub and store them
     in etc-dir/magithub-auth-file."
       (local--update-alist-file magithub--auth-file
                                 (magithub--prompt-for-auth)))
   #+end_src

** Project management
   I use projectile to ease the task of keeping track of files in
   multiple projects and it also ties in well with my mode-line
   config.

   #+name: package/projectile
   #+begin_src emacs-lisp :tangle init.el
     (use-package projectile :ensure t :demand t
       :config
       (setq projectile-cache-file (concat cache-dir "projectile.cache")
             projectile-known-projects-file (concat etc-dir "projectile-bookmarks.el"))
       (projectile-mode))
   #+end_src

** Dired

   Dired is file manager and browser built into Emacs and it is
   efficient enough. By default it shows every file, even hidden ones,
   which results in a lot of noise.

   #+name: dired-hidden-files
   #+begin_src emacs-lisp :tangle init.el
     (require 'dired-x)
     (setq dired-omit-files "^\\...+$")
     (add-hook 'dired-mode-hook (lambda () (dired-omit-mode 1)))
     (define-key dired-mode-map (kbd "C-c h") 'dired-omit-mode)
   #+end_src

   Now, pressing =C-c h= will hide all hidden files in Dired.

* Writing
** TODO Latex

   I want to be able to specify what TeX engine I use when typesetting
   a document. Therefore we add ~TeX-engine~ to the list of safe local
   variables.

   #+name: auctex
   #+begin_src emacs-lisp :tangle init.el
     (eval-after-load 'auctex
       (add-to-list 'safe-local-variable-values '(TeX-engine . xetex)))
   #+end_src


** TODO Pandoc
* Org

  [[http://orgmode.org][Org mode]] is the mode I use to organize my studies, my projects and
  my life in general.

  Set some initialization options regarding time tracking.

  #+name: package/org
  #+begin_src emacs-lisp :tangle init.el
    (use-package org :ensure t :defer t
      :config
      (setq org-clock-persist-file (concat cache-dir "org-clock-save.el")
            org-expiry-inactive-timestamps t
            org-clock-idle-time nil
            org-clock-continuously nil
            org-clock-persist t
            org-clock-in-switch-to-state "IN-PROGRESS"
            org-clock-in-resume nil
            org-log-note-clock-out t
            org-show-notification-handler 'message
            org-clock-report-include-clocking-task t)

      (org-clock-persistence-insinuate))
  #+end_src

  Put all org logs into a drawer.

  #+name: org/drawers
  #+begin_src emacs-lisp :tangle init.el
    (setq org-log-into-drawer "LOGBOOK"
          org-clock-into-drawer t)
  #+end_src

** My files
   :PROPERTIES:
   :CUSTOM_ID: org-files
   :END:

   This is the structure of org files that I want to have and try to
   maintain.

   #<<org-files>>

   | organizer.org         | Main org file, used for org-capture and tasks etc             |
   | people.org            | People-related tasks                                          |
   | journal.org.gpg       | Journal entries (encrypted)                                   |
   | studies.org           | Chalmers-related tasks                                        |
   | reading.org           | Org file for book notes                                       |
   | watching.org          | Org file for stuff I'd like to watch                          |
   | calendar/personal.org | Events and todos from my calendar                             |
   | calendar/family.org   | Events and todos from my familys calendar                     |
   | calendar/spex.org     | Events and todos from the Chalmersspex Bob 2018 calendar      |
   | calendar/ensemble.org | Events and todos from the Ensemble 2018 calendar              |
   | calendar/theatre.org  | Events and todos from the practice schedule for Ensemble 2018 |
   | calendar/chalmers.org | Events and todos from my current Chalmers course schedule     |

** Modules

   There are a lot of modules that extend the core functionality of
   Org mode. This is the modules I personally use and find useful.

   #+name: org/modules-and-export-backends
   #+begin_src emacs-lisp :tangle init.el
     (with-eval-after-load 'org
       (setq org-modules '(org-bbdb
                           org-bibtex
                           org-ctags
                           org-docview
                           org-eww
                           org-gnus
                           org-habit
                           org-info
                           org-irc
                           org-protocol
                           org-rmail
                           org-w3m))

       (org-load-modules-maybe t)

       ;; Export formats
       (setq org-export-backends '(org latex icalendar html ascii)))
   #+end_src

** Keyboard shortcuts

   Some global Org keybindings to set up easy capturing and
   retrieving links and so on.

   #+name: org/global-keybindings
   #+begin_src emacs-lisp :tangle init.el
     (bind-keys ("C-c c"     . org-capture)
                ("C-c a"     . org-agenda)
                ("C-c l"     . org-store-link)
                ("C-c L"     . org-insert-link-global)
                ("C-c O"     . org-open-at-point-global)
                ("<f9> <f9>" . org-agenda-list)
                ("<f9> <f8>" . (lambda () (interactive) (org-capture nil "r"))))
   #+end_src

   Stacking killed content with =append-next-kill= is more useful
   than being able to copy a region in a table.

   #+name: org/keybindings
   #+begin_src emacs-lisp :tangle init.el
     (with-eval-after-load 'org
       (bind-keys
        :map org-mode-map
        ("C-M-w"    . append-next-kill)
        ("C-TAB"    . org-cycle)
        ("C-c v"    . org-show-todo-tree)
        ("C-c C-r"  . org-refile)
        ("C-c R"    . org-reveal)
        ("C-c o"    . local/org-follow-entry-link)
        ("C-c d"    . local/org-move-line-to-destination)
        ("C-c f"    . local/org-file-blog-index-entries)
        ("C-c t s"  . local/split-sentence-and-capitalize)
        ("C-c t -"  . local/split-sentence-delete-word-and-capitalize)
        ("C-c t d"  . local/delete-word-and-capitalize)))
   #+end_src

   Sometimes it could be good to be able to create links between
   tasks, if they for instance depend on each other. These functions
   enable me link tasks and to quickly jump between linked tasks.

   #+name: org/project-links
   #+begin_src emacs-lisp :tangle init.el
     (defun local/org-follow-entry-link ()
       "Follow the defined link for this entry."
       (interactive)
       (if (org-entry-get (point) "LINK")
           (org-open-link-from-string (org-entry-get (point) "LINK"))
         (org-open-at-point)))

     (defun local/org-link-projects (location)
       "Add link properties between the current subtree and the one specified by LOCATION."
       (interactive
        (list (let ((org-refile-use-cache nil))
          (org-refile-get-location "Location"))))
       (let ((link1 (org-store-link nil)) link2)
         (save-window-excursion
           (org-refile 4 nil location)
           (setq link2 (org-store-link nil))
           (org-set-property "LINK" link1))
         (org-set-property "LINK" link2)))
   #+end_src

   To be able to clock in easily is more interesting than the diary.

   #+name: org/clock-in-agenda
   #+begin_src emacs-lisp :tangle init.el
     (with-eval-after-load 'org
         (bind-key "i" 'org-agenda-clock-in org-agenda-mode-map))
   #+end_src

   Killing and yanking subtrees.

   #+name: org/org-cut-subtrees
   #+begin_src emacs-lisp :tangle init.el
     (with-eval-after-load 'org
       (bind-key "C-c k" 'org-cut-subtree org-mode-map)
       (setq org-yank-adjusted-subtrees t))
   #+end_src

*** Speed commands

    Speed commands are simple one-letter commands that are run on
    agenda entries. Used for instance to easily clock in or out on a
    the task at point.

    #+name: org/agenda-speed-commands
    #+begin_src emacs-lisp :tangle init.el
      (defun local/org-use-speed-commands-for-headings-and-lists ()
      "Activate speed commands on list items too."
      (or (and (looking-at org-outline-regexp) (looking-back "^\**"))
          (save-excursion (and (looking-at (org-item-re)) (looking-back "^[ \t]*")))))

      (with-eval-after-load 'org
        (setq org-use-speed-commands 'local/org-use-speed-commands-for-headings-and-lists)

        (add-to-list 'org-speed-commands-user '("x" org-todo "DONE"))
        (add-to-list 'org-speed-commands-user '("y" org-todo-yesterday "DONE"))
        (add-to-list 'org-speed-commands-user '("!" local/org-clock-in-and-track))
        (add-to-list 'org-speed-commands-user '("s" call-interactively 'org-schedule))
        (add-to-list 'org-speed-commands-user '("d" local/org-move-line-to-destination))
        (add-to-list 'org-speed-commands-user '("i" call-interactively 'org-clock-in))
        (add-to-list 'org-speed-commands-user '("o" call-interactively 'org-clock-out))
        (add-to-list 'org-speed-commands-user '("$" call-interactively 'org-archive-subtree))
        (bind-key "!" 'local/org-clock-in-and-track org-agenda-mode-map))
    #+end_src

** Tasks and notes

   I store my org files in "~/personal/" which is a symlink
   to a directory in my Dropbox folder, so I can update it on
   multiple devices (possibly also org-mobile?).

   #+name: org/dir-and-default-settings
   #+begin_src emacs-lisp :tangle init.el
     (setq org-directory (concat (file-name-as-directory (getenv "HOME"))
                                 (file-name-as-directory "personal"))
           org-default-notes-file (concat org-directory "organizer.org")
           org-refile-targets '((org-agenda-files :maxlevel . 6)))
   #+end_src

*** Todo states

    To keep track of my notes and tasks I add some states that my
    notes and tasks could be in. For instance in my reading file,
    items could be READ, READING or WANT-TO-READ. The letters inside
    the parantheses defines keyboard shortcuts that can be used for
    selecting the state of the item. The special characters ~@~ and
    ~!~ defines how logging should be performed. Changing the state
    of an item to a state with a ~@~ prompts you for a note and ~!~
    tells org that it should automatically log timestamp of the state
    change.

    #+name: org/todo-keywords
    #+begin_src emacs-lisp :tangle init.el
      (setq org-todo-keywords
        '((sequence "IDEAS(i)" "TODO(t)" "URGENT(u@/!)"
                    "IN-PROGRESS(p!/@)" "WAITING(w@/@)"
                    "|" "DONE(d@)" "CANCELLED(c@)")
          (sequence "WANT-TO-READ(@)" "READING(!)" "|" "READ(@)")))
    #+end_src

*** Tag tasks

    Many GTD-apps organize the tasks into projects and contexts, this
    is of course doable inside =Org mode= as well.

    #+name: org/task-tags
    #+begin_src emacs-lisp :tangle init.el
      (setq org-tag-alist '(("@work" . ?w)
                            ("@study" . ?s)
                            ("@coding" . ?c)
                            ("@reading" . ?r)
                            ("@home" . ?h)))
    #+end_src

    I'll probably add some more when I have used this for a while.

*** Efforts

    Tasks in =Org mode= can be assigned an effort, so I can know how
    much I'll likely have to invest in a task. This is to help me
    prioritize what tasks that should be done.

    I think that this should make the efforts filterable, so that I
    can find short tasks to complete.

    #+name: org/task-efforts
    #+begin_src emacs-lisp :tangle init.el
      (with-eval-after-load 'org
        (add-to-list 'org-global-properties
                     '("Effort_ALL". "0:05 0:15 0:30 1:00 2:00 3:00 4:00")))
    #+end_src

*** Estimating tasks

    From "Add an effort estimate on the fly when clocking in" on the
    [[http://orgmode.org/worg/org-hacks.html][Org Hacks]] page:

    #+name: org/effort-on-clock-in
    #+begin_src emacs-lisp :tangle init.el
      (add-hook 'org-clock-in-prepare-hook
                'local/org-mode-ask-effort)

      (defun local/org-mode-ask-effort ()
        "Ask for an effort estimate when clocking in."
        (unless (org-entry-get (point) "Effort")
          (let ((effort
                  (completing-read
                    "Effort: "
                    (org-entry-get-multivalued-property (point) "Effort"))))
            (unless (equal effort "")
              (org-set-property "Effort" effort)))))
    #+end_src

*** Habits

    org-habits is a module for =Org mode= that can be used for tasks
    that should be repeated on a regular basis. As such it is great
    to track consistency and create new habits.

    We want to show all habits, not just the ones for today.

    #+name: org/habits-everyday
    #+begin_src emacs-lisp :tangle init.el
    (setq org-habit-show-habits-only-for-today nil)
    #+end_src emacs-lisp

*** Task dependencies

    If tasks depend on each other, make sure that their dependencies
    are enforced by =Org mode= and that this is clear when I show tasks.

    #+name: org/task-dependencies
    #+begin_src emacs-lisp :tangle init.el
      (setq org-enforce-todo-dependencies t
            org-track-ordered-properties-with-tag t
            org-agenda-dim-blocked-tasks t)
    #+end_src

** Structure templates

   You can easily insert blocks in =Org mode= by typing ~<~ followed
   by a letter in ~org-structure-template-alist~ and then pressing the TAB key.
   So lets customize this alist a bit.

   #+name: org/structure-templates
   #+begin_src emacs-lisp :tangle init.el
    (setq org-structure-template-alist
          '(("s" "#+begin_src ?\n\n#+end_src" "<src lang=\"?\">\n\n</src>")
            ("e" "#+begin_example\n?\n#+end_example" "<example>\n?\n</example>")
            ("q" "#+begin_quote\n?\n#+end_quote" "<quote>\n?\n</quote>")
            ("v" "#+BEGIN_VERSE\n?\n#+END_VERSE" "<verse>\n?\n</verse>")
            ("c" "#+BEGIN_COMMENT\n?\n#+END_COMMENT")
            ("p" "#+BEGIN_PRACTICE\n?\n#+END_PRACTICE")
            ("l" "#+begin_src emacs-lisp\n?\n#+end_src" "<src lang=\"emacs-lisp\">\n?\n</src>")
            ("L" "#+latex: " "<literal style=\"latex\">?</literal>")
            ("h" "#+begin_html\n?\n#+end_html" "<literal style=\"html\">\n?\n</literal>")
            ("H" "#+html: " "<literal style=\"html\">?</literal>")
            ("a" "#+begin_ascii\n?\n#+end_ascii")
            ("A" "#+ascii: ")
            ("i" "#+index: ?" "#+index: ?")
            ("I" "#+include %file ?" "<include file=%file markup=\"?\">")))
   #+end_src

** Org Capture templates

   I want to start using =org-capture= to quickly add tasks and notes
   and organize them in my life. First we define some handy templates
   for more advanced capture types, like reading stuff and so
   on.

   #+name: org/capture-templates-variables
   #+begin_src emacs-lisp :tangle init.el
    (defvar local/org-basic-task-template "* TODO %^{Task}
      :PROPERTIES:
      :Effort: %^{effort|1:00|0:05|0:15|0:30|2:00|4:00}
      :END:
      Captured %<%Y-%m-%d %H:%M>
      %?

      %i\n"
      "Basic task data.")

    (defvar local/org-book-template "* WANT-TO-READ %^{Title}  %^g

      %i%?

      *Author(s)*: %^{Author}
      *Review on:* %^t
      %a %U\n"
      "Book template.")

    (defvar local/org-article-template "* WANT-TO-READ %^{Title}  %^g

      *Author(s)*: %^{Author}

      *Abstract*: %i%?

      [[%l][Link to paper]]\n"
      "Article template.")

    (defvar local/org-blog-post-template "* WANT-TO-READ %^{Title}  %^g

      %i

      *Author(s)*: %^{Author}

      [[%l][Link to blog post]]\n"
      "Blog post template.")
   #+end_src

   Quick legend of the template escape codes:
   - ~%^{PROMPT}~ - Org will prompt me with "PROMPT: " and the input
     will replace the occurrance of ~%^{Task}~ in the template,
   - ~%?~ - Org will put the cursor here so I can edit the capture
     before refiling it,
   - ~%i~ - Org will insert the marked region from before the capture
     here,
   - ~%a~ - Org will insert an annotation here (,
   - ~%U~ - Org will insert an inactive timestamp here,
   - ~%l~ - Org will insert a literal link here,

   #+name: org/capture-templates
   #+begin_src emacs-lisp :tangle init.el
     (setq org-capture-templates
           `(("t" "Tasks" entry
              (file+headline ,org-default-notes-file "Inbox")
              ,local/org-basic-task-template)

             ("T" "Quick task" entry
              (file+headline ,org-default-notes-file "Inbox")
              "* TODO %^{Task}\nSCHEDULED: %t\n" :immediate-finish t)

             ("i" "Interrupting task" entry
              (file+headline ,org-default-notes-file "Inbox")
              "* IN-PROGRESS %^{Task}\n" :clock-in :clock-resume)

             ("E" "Energy" table-line
              (file+headline ,org-default-notes-file "Track energy")
              "| %U | %^{Energy 5-awesome 3-fuzzy 1-zzz} | %^{Note} |"
              :immediate-finish t)

             ("p" "People task" entry
              (file+headline ,(concat org-directory "people.org") "Tasks")
              ,local/org-basic-task-template)

             ("j" "Journal entry" plain
              (file+datetree ,(concat org-directory "journal.org.gpg"))
              "%K - %a\n%i\n%?\n" :unnarrowed t)

             ("J" "Journal entry with date" plain
              (file+datetree+prompt ,(concat org-directory "journal.org.gpg"))
              "%K - %a\n%i\n%?\n" :unnarrowed t)

             ("s" "Journal entry with date, scheduled" entry
              (file+datetree+prompt ,(concat org-directory "journal.org.gpg"))
              "* \n%K - %a\n%t\t%i\n%?\n" :unnarrowed t)

             ("c" "Protocol Link" entry (file+headline ,org-default-notes-file "Inbox")
              "* [[%:link][%:description]] \n\n#+BEGIN_QUOTE\n%i\n#+END_QUOTE\n\n%?\n\nCaptured: %U\n")

             ("dp" "Done - People" entry
              (file+headline ,(concat org-directory "people.org") "Tasks")
              "* DONE %^{Task}\nSCHEDULED: %^t\n%?")

             ("dt" "Done - Task" entry
              (file+headline ,org-default-notes-file "Inbox")
              "* DONE %^{Task}\nSCHEDULED: %^t\n%?")

             ("q" "Quick note" item
              (file+headline ,org-default-notes-file "Quick notes"))

             ("B" "Book" entry
              (file+headline ,(concat org-directory "reading.org") "Books")
              ,local/org-book-template :clock-resume)

             ("A" "Article" entry
              (file+headline ,(concat org-directory "reading.org") "Articles")
              ,local/org-article-template :clock-resume)

             ("p" "Blog post" entry
              (file+headline ,(concat org-directory "reading.org") "Blog entries")
              ,local/org-blog-post-template :clock-resume)

             ("l" "Bookmark" entry
              (file+headline ,(concat org-directory "bookmarks.org")
                             "Captured entries")
              "* [[%^{Link}][%^{Title}]]\n\n%i%?\n")

             ("n" "Daily note" table-line
              (file+olp ,org-default-notes-file "Inbox")
              "| %u | %^{Note} |" :immediate-finish t)

             ("r" "Notes" entry
              (file+datetree ,org-default-notes-file)
              "* %?\n\n%i\n%U\n")

             ;; Org protocol handlers
             ("p" "Protocol" entry
              (file+headline ,(concat org-directory "notes.org") "Inbox")
              "* %^{Title}\nSource: %u, %c\n #+BEGIN_QUOTE\n%i\n#+END_QUOTE\n\n\n%?\n")

             ("L" "Protocol Link" entry
              (file+headline ,(concat org-directory "notes.org") "Inbox")
              "* %? [[%:link][%:description]] \nCaptured On: %U\n")))

     (bind-key "C-M-r" 'org-capture)
   #+end_src

** Org agenda
*** Basic configuration

    I like to show ordinary txt files as =Org mode= files.

    #+begin_src emacs-lisp :tangle init.el
      (add-to-list 'auto-mode-alist '("\\.txt$" . org-mode))
    #+end_src

    This is the org files in which I keep agenda items and todos.

    #+name: org/agenda-files
    #+begin_src emacs-lisp :tangle init.el
      (defun local/existing-files-in-dir (dir files)
        "Return all files from the list FILES that exists in directory DIR."
        (delq nil (mapcar
                   (lambda (file) (let ((path (concat dir file)))
                                    (and (file-exists-p path) path)))
                   files)))

      (setq org-agenda-files (local/existing-files-in-dir
                              org-directory
                              '("organizer.org" "people.org" "bookmarks.org"
                                "studies.org" "reading.org"

                                ;; Calendar files (synced with org-gcal)
                                "calendar/family.org" "calendar/personal.org"
                                "calendar/spex.org" "calendar/ensemble.org"
                                "calendar/chalmers.org" "calendar/theatre.org")))
    #+end_src

    We want the agenda to show us a time grid and the log entries. We
    also want the agenda to hide finished items, even if they are
    scheduled.

    #+name: org/agenda-settings
    #+begin_src emacs-lisp :tangle init.el
      (setq org-agenda-tags-column -100
            org-agenda-sticky nil
            org-agenda-use-tag-inheritance t
            org-agenda-show-log t
            org-agenda-skip-scheduled-if-done t
            org-agenda-skip-deadline-if-done t
            org-agenda-skip-scheduled-if-deadline-is-shown 'not-today
            org-agenda-skip-deadline-prewarning-if-scheduled nil
            org-agenda-time-grid
            '((daily today require-timed)
              (800 1000 1200 1400 1600 1800 2000)
              "......"
              "----------------")
            org-columns-default-format "14%DEADLINE %Effort{:} %CLOCKSUM %1PRIORITY %TODO %50ITEM %TAGS")
    #+end_src

    Sometimes I want to be able to exclude stuff from the agenda view,
    like for instance courses that I havn't finished but plan to
    finish another time.

    =local/org-auto-exclude-function= excludes entries based on their
    tag, in this case it hides todos tagged with "net" if the network
    is down, errands and calls are hidden during non-work time and
    inactive tasks are always hidden.

    #+name: org/exclude-function
    #+begin_src emacs-lisp :tangle init.el
      (defun local/org-auto-exclude-function (tag)
        (and (cond
              ((string= tag "net")
               (/= 0 (call-process "/sbin/ping" nil nil nil
                                   "-c1" "-q" "-t1" "mail.gnu.org")))
              ((or (string= tag "Errand") (string= tag "Call"))
               (let ((hour (nth 2 (decode-time))))
                 (or (< hour 8) (> hour 21))))
              ((string= tag "inactive")
               t))
             (concat "-" tag)))

      (setq org-agenda-auto-exclude-function 'local/org-auto-exclude-function)
    #+end_src
*** TODO Fix so that entries completed @ 01 is counted as yesterday.
** Publishing

   I want to be able to view my org documents so that I can see my
   progress and what I've got left to do and so on. Org publish works
   rather well for this scenario, even though I probably would like
   do some automation on when it does the publishing.

   #+name: org/publishing
   #+begin_src emacs-lisp :tangle init.el
     (require 'ox-html)
     (setq org-publish-project-alist
           `(("html"
              :base-directory ,org-directory
              :base-extension "org"
              :publishing-directory "/ssh:jassob:/var/www/org"
              :recursive t
              :publishing-function org-html-publish-to-html)

             ("org-static"
              :base-directory ,org-directory
              :base-extension "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf"
              :publishing-directory "/ssh:jassob:/var/www/org"
              :recursive t
              :publishing-function org-publish-attachment)

             ("archive"
              :base-directory ,org-directory
              :base-extension "org_archive"
              :publishing-directory "/ssh:jassob:/var/www/org/archive"
              :publishing-function org-html-publish-to-html)

             ("web"
              :base-directory ,(concat org-directory "web/")
              :base-extension "org"
              :publishing-directory "/ssh:jassob:/var/www/"
              :publishing-function org-html-publish-to-html)

             ("jassob" :components ("html" "archive" "org-static" "web"))
             ("all" :components ("jassob"))))

     (defun local/publish-jassob ()
       "Publishes \"jassob\" project"
       (interactive)
       (org-publish "jassob" t))

     (defun local/publish-chalmers ()
       "Publishes \"chalmers\" project"
       (interactive)
       (org-publish "chalmers" t))

     (defun local/publish-web ()
       "Publishes \"web\" project"
       (interactive)
       (org-publish "web" t))
   #+end_src

** Access Google Calendar

   Even though I use =org-mode= for scheduling a lot of tasks and
   other stuff I also use Google Calendar to organize stuff together
   with other people, this section is about how I make these two work
   together.

   First some nifty helping functions to handle retrieving and storing
   credentials.

   #+name: org-gcal/functions
   #+begin_src emacs-lisp :tangle init.el
     (defun org-gcal--get-credentials ()
       "Get the stored client id and client secret from FILEPATH and return it a conscell in form of (CLIENT_ID . CLIENT_SECRET)."
       (if (file-exists-p org-gcal--auth-file)
           (read-from-file org-gcal--auth-file)
         (warn "org-gcal credential file does not exist, run org-gcal--init-credentials.")))

     (defun org-gcal--prompt-for-credentials ()
       "Prompt the user for a Google API client id and client secret and store them in org-gcal--auth-file."
       (let ((client_id (read-from-minibuffer "Client ID: ")))
         (let ((client_secret (read-from-minibuffer "Client Secret: ")))
           (cons client_id client_secret))))

     (defun org-gcal--update-credentials ()
       "Update the org-gcal credential file with information from the user."
       (interactive)
       (local--update-alist-file org-gcal--auth-file
                                 (org-gcal--prompt-for-credentials)))
   #+end_src

   Now that we have our functions in place, let's use them when
   customizing our org-gcal package.

   #+name: package/org-gcal
   #+begin_src emacs-lisp :tangle init.el
     (use-package org-gcal
       :init
       (defvar org-gcal--auth-file (concat etc-dir "org-gcal-auth-file"))
       (local--init-file-if-missing org-gcal--auth-file
                                    #'org-gcal--prompt-for-credentials)
       (let ((credentials (org-gcal--get-credentials)))
           (setq org-gcal-client-id (car credentials)
                 org-gcal-client-secret (cdr credentials)))
       (setq org-gcal-dir (concat etc-dir "org-gcal/")
             org-gcal-token-file (concat org-gcal-dir ".org-gcal-token"))
       (if (file-exists-p (concat etc-dir "org-gcal-file-alist-file"))
           (setq org-gcal-file-alist (eval (read-from-file (concat etc-dir "org-gcal-file-alist-file"))))
         (warn (concat "File " (concat etc-dir "org-gcal-file-alist-file")
                       " not found. Create it and fill it with an alist in "
                       "the following format: "
                       "'(( \"calendar-id\" . \"calendar-org-file\"))"))))
   #+end_src

* Coding
** Common settings for programming languages

   There are some common things I want to use for all every
   programming language I code in. For instance I would like error
   checking and auto-completion when it exists and line indicators
   that shows if a line is modified, added or removed.

   #+name: common-code-mode
   #+begin_src emacs-lisp :tangle init.el
     (define-minor-mode common-code-mode
       "A minor mode for enabling common minor modes and other
       features for programming modes."
       :lighter " Code"
       :keymap (let (keymap (make-sparse-keymap))
                 (bind-key "C-c g" #'god-mode keymap)
                 keymap)

       (if (>= emacs-major-version 26)
           (setq display-line-numbers 'on)
         (progn
           (add-hook 'common-code-mode-hook 'linum-mode))))

     (add-hook 'common-code-mode-hook 'flycheck-mode)
     (add-hook 'common-code-mode-hook 'company-mode)
     (add-hook 'common-code-mode-hook 'git-gutter+-mode)
     (add-hook 'common-code-mode-hook 'hs-minor-mode)
     (add-hook 'common-code-mode-hook 'rainbow-delimiters-mode)
     (add-hook 'common-code-mode-hook 'auto-revert-mode)
     (add-hook 'common-code-mode-hook 'smartparens-mode)
     (add-hook 'common-code-mode-hook 'subword-mode)
     (add-hook 'common-code-mode-hook 'hl-line-mode)
   #+end_src

   I want trailing white space to be removed automatically before saving.

   #+name: common-code-map/trailing-whitespace
   #+begin_src emacs-lisp :tangle init.el
     (add-hook 'common-code-mode-hook
               (lambda () (add-hook 'before-save-hook
                                    #'delete-trailing-whitespace)))
   #+end_src

   I want Emacs Lisp to use my fancy new minor mode.

   #+name: common-code-mode/elisp
   #+begin_src emacs-lisp :tangle init.el
     (add-hook 'emacs-lisp-mode-hook 'common-code-mode)
   #+end_src

   Install the needed packages in case they don't exists.

   #+name: package/common-code-mode-dependencies
   #+begin_src emacs-lisp :tangle init.el
     ;; Syntax and error checker
     (use-package flycheck :ensure t)

     ;; Auto completion
     (use-package company :ensure t :diminish t)

     ;; Rainbow delimiters
     (use-package rainbow-delimiters :ensure t)

     ;; Relative line numbering
     (use-package linum-relative :ensure t)

     ;; Parens handling
     (use-package smartparens :ensure t :diminish t
       :init
       (require 'smartparens-config))
   #+end_src

** Java
** Haskell

   Structuring haskell files as documented modules is good practice,
   although I don't remember doing it by myself so let us add functions
   that do this automatically in new files.

   #+name: haskell/auto-insert-module-template
   #+begin_src emacs-lisp :tangle init.el
     (defun haskell-auto-insert-module-template ()
       "Insert a module template for the newly created buffer."
       (interactive)
       (when (and (= (point-min)
                     (point-max))
                  (buffer-file-name))
         (insert "-- | "
                 "\n"
                 "module ")
         (let ((name (haskell-guess-module-name)))
           (if (string= name "")
               (progn (insert "Main")
                      (shm-evaporate (- (point) 5)
                                     (point)))
             (insert name)))
         (insert " where"
                 "\n"
                 "\n")
         (goto-char (point-min))
         (forward-char 4)
         (god-mode)))
   #+end_src

   Undefined is a long and complicated word to type correctly and I
   write it a lot when coding Haskell so here is a shortcut for it.

   #+name: haskell/insert-undefined
   #+begin_src emacs-lisp :tangle init.el
     (defun haskell-insert-undefined ()
       "Insert undefined."
       (interactive)
       (insert "undefined"))
   #+end_src

   Next stop is to actually install and configure the modes and packages.

   #+name: package/haskell
   #+begin_src emacs-lisp :tangle init.el
     (use-package haskell-mode
       :mode "\\.hs$"
       :mode ("\\.ghci$ . ghci-script-mode")
       :mode ("\\.cabal$ . haskell-cabal-mode")
       :interpreter (("runghc" . haskell-mode)
                     ("runhaskell" . haskell-mode))
       :bind
       (:map haskell-mode-map
             ("C-`"     . haskell-interactive-bring)
             ("C-c C-r" . xref-find-references)
             ("C-c C-," . xref-find-definitions)
             ("C-c C-." . pop-tag-mark)
             ("C-c C-t" . haskell-process-do-type)
             ("C-c c"   . haskell-process-cabal)
             ("C-c C-c" . haskell-process-cabal-build)
             ("C-c C-u" . haskell-insert-undefined)
             ("C-c C-a" . haskell-insert-doc))
       :config
       (setq haskell-tags-on-save t)
       (add-hook 'haskell-mode-hook 'common-code-mode)
       (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
       (add-hook 'haskell-mode-hook 'haskell-auto-insert-module-template)

       (if (string-match-p (regexp-quote "Hasklig")
                           (aref (query-font (face-attribute 'default :font)) 0))
           (progn
             (setq haskell-font-lock-symbols nil)
             (add-hook 'haskell-mode-hook 'my-set-hasklig-ligatures))
         (setq haskell-font-lock-symbols 'unicode)))

     (use-package dante :after haskell-mode :diminish t
       :init
       (if (executable-find "cabal")
           (progn
             (add-hook 'haskell-mode-hook 'dante-mode))
         (warn "haskell-mode: couldn't find cabal"))
       :config
       (setq dante-load-flags '("+c" "-Wall"
                                "-Wwarn=missing-home-modules"
                                "-fno-diagnostics-show-caret"))
       (add-hook 'dante-mode-hook
                 (lambda ()
                   (flycheck-add-next-checker 'haskell-dante
                                              '(warning . haskell-hlint))
                   (add-to-list 'flycheck-disabled-checkers 'haskell-stack-ghc)))

       ;; Find out the right repl to use from what files exists in project root.
       (setq-default dante-repl-command-line-methods-alist
                     `((styx . ,(lambda (root)
                                  (dante-repl-by-file root '("styx.yaml")
                                                      '("styx" "repl"))))
                       (nix-new . ,(lambda (root)
                                     (dante-repl-by-file
                                      (projectile-project-root)
                                      '("shell.nix" "default.nix")
                                      `("nix-shell" "--run" "cabal new-repl"
                                        ,(concat (projectile-project-root) "/shell.nix")))))
                       (stack . ,(lambda (root)
                                   (dante-repl-by-file root '("stack.yaml")
                                                       '("stack" "repl"))))
                       (bare  . ,(lambda (_) '("cabal" "repl"))))))
   #+end_src

** Agda

   Agda is a functional programming language / functional logic with
   support for dependant types. It is used in some courses at
   Chalmers, where it is also mainly developed.

   #+name: package/agda
   #+begin_src emacs-lisp :tangle no
     (load-file (let ((coding-system-for-read 'utf-8))
                  (shell-command-to-string "agda-mode locate")))

     (add-hook 'agda2-mode-hook 'common-code-mode)
   #+end_src

** TODO Python

   When programming in Python I want the same tooling as I have when
   programming Haskell. Thanks to company and flycheck, I get some
   helpful information about the code.

   #+name: package/python
   #+begin_src emacs-lisp :tangle init.el
     (use-package python-mode :commands python-mode
       :init
       (add-hook 'python-mode-hook 'common-code-mode)
       (add-hook 'python-mode-hook
                 (lambda ()
                   (setq tab-width 4)
                   (setq python-indent-offset 4)
                   (setq indent-tabs-mode nil)))
       :bind
       (:map python-mode-map
             ("C-<backspace>" . backward-kill-word))

       :config
       (setq python-environment-directory cache-dir
             python-indent-guess-indent-offset-verbose nil
             python-shell-interpreter "python")
       (when (executable-find "ipython")
         (setq python-shell-interpreter "ipython"
               python-shell-interpreter-args "-i --simple-prompt --no-color-info"
               python-shell-prompt-regexp "In \\[[0-9]+\\]: "
               python-shell-prompt-block-regexp "\\.\\.\\.\\.: "
               python-shell-prompt-output-regexp "Out\\[[0-9]+\\]: "
               python-shell-completion-setup-code "from IPython.core.completerlib import module_completion"
               python-shell-completion-string-code "';'.join(get_ipython().Completer.all_completions('''%s'''))\n"))

       (sp-with-modes 'python-mode
         (sp-local-pair "'" nil :unless
                        '(sp-point-before-word-p sp-point-after-word-p
                                                 sp-point-before-same-p))))
   #+end_src

   As a Haskell-programmer I enjoy having the tools checking my types
   for me and since Python 3.5 they added support for type hints in
   Python. [[http://mypy-lang.org/][Mypy]] is a type checker for python and [[https://github.com/lbolla/emacs-flycheck-mypy][flycheck-mypy]] is an
   Flycheck interface for said type checker.

   #+name: package/flycheck-mypy
   #+begin_src emacs-lisp :tangle init.el
     (use-package flycheck-mypy :defer t
       :init
       (add-to-list 'flycheck-disabled-checkers 'python-flake8)
       (add-to-list 'flycheck-disabled-checkers 'python-pylint)
       (add-to-list 'flycheck-disabled-checkers 'python-pycompile))
       (setq flycheck-python-mypy-args '("--ignore-missing-imports"))
   #+end_src


   It is a convention to store a list of required dependencies in a
   file called =requirements.txt=, which can easily be installed by
   pip with the command

   #+begin_src bash
   $ pip install -r requirements.txt
   #+end_src

   To generate a fresh version of requirements.txt we run

   #+begin_src bash
   $ pip freeze > requirements.txt
   #+end_src

   There exists an Emacs mode for the requirement-file-format in pip.

   #+name: package/pip-requirements
   #+begin_src emacs-lisp :tangle init.el
     (use-package pip-requirements
       :mode ("/requirements.txt$" . pip-requirements-mode))
   #+end_src

** Web-mode

   I use web-mode for when I have to do web programming and I actually
   consider it programming, so I'll want to load my ~common-code-mode~.

   #+name: package/web-mode
   #+begin_src emacs-lisp :tangle init.el
     (use-package web-mode :ensure t :mode "\\.dtl$"
       :init
       (add-hook 'web-mode-hook 'common-code-mode)
       :config
       (if web-mode-engines-alist
           (add-to-list 'web-mode-engines-alist '("django" . "\\.dtl$\\'"))
         (setq web-mode-engines-alist '(("django" . "\\.dtl$\\'")))))
   #+end_src

** C#

   During my internship at Ascom I coded a lot of C# and .NET which of
   course made me use Visual Studio which is, considering that it is
   an IDE, not that frustrating. I missed my keybindings and all
   custom stuff that I can use on Emacs so I went out looking for
   packages that enabled the same kind of tooling that I found helpful
   in VS. I found [[http://www.omnisharp.net/][OmniSharp]] to be the package I was looking for and
   together with [[https://github.com/josteink/csharp-mode][csharp-mode]] they provide everything I need to code C#
   in Emacs, even though I still need to use VS to run tests and
   build.

   #+name: package/csharp
   #+begin_src emacs-lisp :tangle init.el
     (use-package csharp-mode :defer t
       :mode "\\.cs'"
       :config
       (add-hook 'csharp-mode-hook 'omnisharp-mode))

     (use-package omnisharp :defer t
       :config
       (when (eq system-type 'windows-nt)
         (setq-default omnisharp-server-executable-path
                       (concat include-dir "omnisharp/OmniSharp.exe")))
       :bind (:map csharp-mode-map
              ("M-."   . omnisharp-find-implementations)
              ("C-M-." . omnisharp-find-usages)))
   #+end_src

** Nix
   When writing Nix expressions I want to activate the minor modes
   active that I have when coding.

   #+name: package/nix-mode
   #+begin_src emacs-lisp :tangle init.el
     (use-package nix-mode
       :init
       (add-hook 'nix-mode-hook 'common-code-mode))
   #+end_src

* Reading

  Emacs works beautifully as a PDF reader with the ~pdf-tools~
  package! However by default it advances automatically to the next
  page when scrolling past the current page, which I find annoying
  when scolling with a touchpad. So I disable ~pdf-view-continous~ and
  use =SPC= to scroll and advance the pages instead.

  #+name: package/pdf-tools
  #+begin_src emacs-lisp :tangle init.el
    (use-package pdf-tools :defer t
      :config
      (pdf-tools-install)
      (setq pdf-view-continuous nil)
      (add-to-list 'auto-mode-alist pdf-tools-auto-mode-alist-entry))
  #+end_src

* Multimedia

  EMMS (Emacs MultiMedia System) is a mode for playing music.

  #+name: package/emms
  #+begin_src emacs-lisp :tangle init.el
    (use-package emms :defer t
      :config (setq emms-directory (concat cache-dir "emms")))
  #+end_src

* Communication

  I use weechat for communicating over IRC because of it's relay
  features. Weechat relays enable me to use a good enough Android app,
  or http://glowing-bear.org to access my chat session.

  In the future I might get around to fix my znc (a IRC bouncer) setup
  and will thus not need to use a separate chat protocol besides IRC,
  but until then I stick with weechat.

  #+name: package/weechat
  #+begin_src emacs-lisp :tangle init.el
    (use-package weechat :commands (weechat-connect)
      :init (defvar weechat--auth-file (concat etc-dir "weechat-auth-file"))
      :config
      (local--init-file-if-missing weechat--auth-file
                                   #'weechat--prompt-for-auth)
      (setq weechat-color-list '(unspecified "black" "dark gray" "dark red"
                                             "red" "dark green" "light green"
                                             "brown" "yellow" "deepskyblue3"
                                             "light blue" "dark magenta"
                                             "magenta" "dark cyan" "light cyan"
                                             "gray" "white")
            weechat-modules '(weechat-button weechat-complete weechat-notifications)
            weechat-password-callback #'weechat--get-password)
      (add-hook 'weechat-connect-hook 'weechat-monitor-all-buffers))

    (defun weechat--get-password (host port)
      "Get the stored password from a credentials file.
    The credentials file should store an alist in the form ((HOST
    . PORT) . PASSWORD)."
      (if (file-exists-p weechat--auth-file)
          (let ((passwd-alist (read-from-file weechat--auth-file)))
            (cdr (assoc (cons host port) passwd-alist)))
        (warn "Weechat auth file does not exist, can not auto-connect.")))
  #+end_src

  To simplify the customization of =weechat= credentials I've created
  this function to create the =weechat-auth-file= in the correct
  format.

  #+name: weechat/auth-settings
  #+begin_src emacs-lisp :tangle init.el
    (defun weechat--prompt-for-auth ()
      "Store the weechat credentials in =etc-dir/weechat-auth-file.el=."
      (let ((host (read-from-minibuffer "Host: ")))
        (let ((port (string-to-int (read-from-minibuffer "Port: "))))
          (let ((password (read-passwd "Password: ")))
            (cons (cons host port) password)))))

    (defun weechat--update-auth-info ()
      "Updates the weechat authentication file with information from
    the user."
      (interactive)
      (local--update-alist-file weechat--auth-file
                                (weechat--prompt-for-auth)))
  #+end_src

* Different configs

  I've added =noweb= references to every code block that I want
  tangled to source files. Therefore I can select which source blocks
  I want for less complete environments, to save startup time.

  We start by defining what code blocks are common for every config.

  #+name: common-base-config
  #+begin_src emacs-lisp :noweb yes
    ;; System init stuff
    <<sys-dir-init>>
    <<create-sys-dir>>
    <<package/settings>>
    <<package/use-package>>
    <<file-help-funs>>
    <<tramp-dir-settings>>
    <<org/dir-and-default-settings>>
    <<dvorak-bindings>>
    <<utf8>>

    ;; Backup and auto-save
    <<set-backup-directory-alist>>
    <<backup-settings>>
    <<auto-save-settings>>
    <<identity-stuff>>
    <<local-alist-funs>>
    <<local-keymap-functions>>
    <<local-keymap>>
    <<toolbar-settings>>
    <<hide-splash-screen>>

    ;; Packages
    <<package/smex>>
    <<package/guide-key>>
    <<package/recentf>>
    <<font-settings>>
    <<theme-settings>>
    <<windmove-keybindings>>
    <<buf-move-keybindings>>
    <<resize-window-keybindings>>
  #+end_src

  Because I want to be able to script stuff with =org-gcal= and other
  =org= packages I think I need a smaller emacs+org config.

  #+name: org-gcal
  #+begin_src emacs-lisp :noweb yes :tangle minimal.el
    ;; System init stuff
    <<sys-dir-init>>
    <<create-sys-dir>>
    <<package/settings>>
    <<package/use-package>>
    <<file-help-funs>>
    <<tramp-dir-settings>>
    <<org/dir-and-default-settings>>
    <<utf8>>

    ;; Backup and auto-save
    <<set-backup-directory-alist>>
    <<backup-settings>>
    <<auto-save-settings>>
    <<identity-stuff>>
    <<local-alist-funs>>
    <<local-keymap-functions>>
    <<local-keymap>>

    ;; Packages
    <<org-gcal/functions>>
    <<package/org-gcal>>
  #+end_src

  #+name: base+org
  #+begin_src emacs-lisp :noweb yes :tangle org.el
    <<common-base-config>>

    ;; Org stuff
    <<package/org>>
    <<org/drawers>>
    <<org/modules-and-export-backends>>
    <<org/global-keybindings>>
    <<org/keybindings>>
    <<org/project-links>>
    <<org/clock-in-agenda>>
    <<org/org-cut-subtrees>>
    <<org/agenda-speed-commands>>
    <<org/todo-keywords>>
    <<org/task-tags>>
    <<org/task-efforts>>
    <<org/effort-on-clock-in>>
    <<org/habits-everyday>>
    <<org/task-dependencies>>
    <<org/structure-templates>>
    <<org/capture-templates-variables>>
    <<org/capture-templates>>
    <<org/agenda-files>>
    <<org/agenda-settings>>
    <<org/exclude-function>>
    <<org/publishing>>
    <<org-gcal/functions>>
    <<package/org-gcal>>
  #+end_src

  Other kinds of configs are the coding configs and since they will be
  largely the same we start by defining a base code config.

  #+name: code-config
  #+begin_src emacs-lisp :noweb yes
    <<common-base-config>>
    <<common-code-mode>>
    <<common-code-map/trailing-whitespace>>
    <<common-code-map/elisp>>
    <<package/common-code-mode-dependencies>>
    <<package/projectile>>
    <<package/magit>>
    <<package/multiple-cursors>>
  #+end_src

  A Haskell config.

  #+begin_src emacs-lisp :tangle haskell.el :noweb yes
    <<code-config>>
    <<font-settings>>
    <<ligature-settings>>
    <<package/haskell>>
    <<haskell/auto-insert-module-template>>
    <<haskell/insert-undefined>>
  #+end_src

  A Python config.

  #+begin_src emacs-lisp :tangle python.el :noweb yes
    <<code-config>>
    <<package/python>>
    <<package/flycheck-mypy>>
    <<package/pip-requirements>>
  #+end_src

  A Web development config.

  #+begin_src emacs-lisp :tangle web.el :noweb yes
    <<code-config>>
    <<package/web-mode>>
  #+end_src

  A C# config.

  #+begin_src emacs-lisp :tangle csharp.el :noweb yes
    <<code-config>>
    <<package/csharp>>
  #+end_src

  A Nix config.

  #+begin_src emacs-lisp :tangle nix.el :noweb yes
    <<code-config>>
    <<package/csharp>>
  #+end_src
