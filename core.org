# -*- indent-tabs-mode: nil; -*-
#+TITLE: Core EMACS configuration
#+DATE: <2018-01-19 Fri>

* About this file
  This file contains the core configuration for my Emacs setup.
  It consists of settings that I considered are sane defaults.

* Emacs initialisation
** System directories

   I don't like keeping a lot of files visible in my =.emacs.d=
   directory, so let's create a directory hierarchy for all files that
   I'm not interested in.

   #+begin_src emacs-lisp :tangle core.el
     (defvar packages-dir (concat user-emacs-directory "packages/")
       "Where package.el packages and cache are stored.")

     (defvar include-dir (concat user-emacs-directory "include/")
       "Where we store stuff that's not part of emacs packages or
         other dependencies.")

     (defvar org-directory (concat (expand-file-name "~") "/org")
       "Where we store Org mode documents.")
   #+end_src

   We need to make sure that the directories are created before we try
   to make Emacs store stuff there.

   #+begin_src emacs-lisp :tangle core.el
     (dolist (dir (list packages-dir include-dir))
       (unless (file-exists-p dir)
         (make-directory dir t)))
   #+end_src

   We might want to read and store values to/from a file, these
   routines lets us store Emacs lisp values and then retrieve them.

   #+begin_src emacs-lisp :tangle core.el
     (defun print-to-file (filename data)
       "Create FILENAME and store DATA inside it."
       (with-temp-file filename
         (prin1 data (current-buffer))))

     (defun read-from-file (filename)
       "Read Emacs Lisp variables from FILENAME."
       (with-temp-buffer
         (insert-file-contents filename)
         (cl-assert (eq (point) (point-min)))
         (read (current-buffer))))
   #+end_src

   Sometimes updating config files and creating them if they don't
   exist is a common operation, such as activating a mode for the
   first time.

   #+begin_src emacs-lisp :tangle core.el
     (defun local--update-alist-file (file val)
       "Update FILE with value VAL.
     If FILE exists VAL will be appended to it's variable,
     otherwise VAL will be stored in a new file FILE."
       (if (file-exists-p file)
           (let ((alist (read-from-file file)))
             (add-to-list 'alist val)
             (print-to-file file alist))
         (print-to-file file val)))

     (defun local--init-file-if-missing (file init-fn)
       "Check if FILE exists and if not it creates it and initializes
      it with the unary function INIT-FN."
       (unless (file-exists-p file)
         (print-to-file file (list (funcall init-fn)))))
   #+end_src

** Editing system files

   When I edit system configuration files I might accidentally find
   files as my regular user, even though I need sudo rights to edit
   them. This advice makes =ido-find-file= automatically open it
   through =TRAMP= as sudo if it is not writable by my user.

   #+begin_src emacs-lisp :tangle core.el
     (defadvice ido-find-file (after find-file-sudo activate)
       "Find file as root if necessary."
       (when (and buffer-file-name
                  (not (file-writable-p buffer-file-name))
                  (y-or-n-p "Do you want to edit as sudo?"))
         (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))
   #+end_src

** Packages

   First we need to activate the package system and add the melpa
   repository, if it is not already added.

   #+begin_src emacs-lisp :tangle core.el
      (require 'package)
      (setq package-user-dir (expand-file-name "elpa" packages-dir)
            package-archives '(("gnu"   . "https://elpa.gnu.org/packages/")
                               ("melpa" . "https://melpa.org/packages/")))
      (package-initialize)

      ;; We've already enabled the package system.
      (setq package-enable-at-startup nil)
   #+end_src

   Make sure to reload the list of packages by calling =M-x
   package-refresh-contents= when adding melpa for the first time.

   I use =use-package= for keeping track of my packages, customising
   them and load them lazily.

   #+begin_src emacs-lisp :tangle core.el
     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))
     (setq use-package-verbose t)
   #+end_src

   I found the =no-littering= package while browsing around, and
   decided I'll give it a go rather than doing that work myself.

   #+begin_src emacs-lisp :tangle core.el
     (use-package no-littering :ensure t
       :config
       ;; Save automatic backups in var dir
       (setq auto-save-file-name-transforms
           `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))

       ;; Save custom settings in etc dir
       (setq custom-file (no-littering-expand-etc-file-name "custom.el")))
   #+end_src

** Secrets and custom settings

   I store more sensitive data in =~/.emacs.d/etc/.secrets.el= so I
   easily can store my main configuration in a public version control
   system.

   #+begin_src emacs-lisp :tangle core.el
     (load (concat (no-littering-expand-etc-file-name ".secrets.el")) t)
   #+end_src
* Editor
** Encoding system
   We would like Emacs to prefer UTF8 when reading ambiguous bit
   strings.

   #+begin_src emacs-lisp :tangle core.el
     (prefer-coding-system 'utf-8)
     (when (display-graphic-p)
       (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
   #+end_src

** Buffer and window navigation

   Switching between windows can be a bit of a pain, just cycling
   through them with =C-x o= is not really good enough. I therefore
   use ~windmove~ and ~buffer-move~ to navigate amongst my buffers and
   I have them bound to, in my opinion at least, sensible keybindings.

   #+begin_src emacs-lisp :tangle core.el
     (bind-keys ("<S-s-left>"  . windmove-left)
                ("<S-s-up>"    . windmove-up)
                ("<S-s-down>"  . windmove-down)
                ("<S-s-right>" . windmove-right))
   #+end_src

   Sometimes it is nice to be able to shrink and enlarge windows
   easily and that is why I've bounded them to simple keys:

   #+begin_src emacs-lisp :tangle core.el
     (bind-keys ("S-C-<left>"  . shrink-window-horizontally)
                ("S-C-<right>" . enlarge-window-horizontally)
                ("S-C-<down>"  . shrink-window)
                ("S-C-<up>"    . enlarge-window))
   #+end_src

** Dired

   Dired is file manager and browser built into Emacs and it is
   efficient enough. By default it shows every file, even hidden ones,
   which results in a lot of noise.

   #+begin_src emacs-lisp :tangle core.el
     (require 'dired-x)
     (setq dired-omit-files "^\\...+$")
     (add-hook 'dired-mode-hook (lambda () (dired-omit-mode 1)))
     (define-key dired-mode-map (kbd "C-c h") 'dired-omit-mode)
   #+end_src

   Now, pressing =C-c h= will hide all hidden files in Dired.
* Common programming settings

  There are some common things I want to use for all every
  programming language I code in. For instance I would like error
  checking and auto-completion when it exists and line indicators
  that shows if a line is modified, added or removed.

  Worth noting is that I turn off Transient Mark mode in Common-Code
  minor mode, because I like to use the tag stack for navigation (i.e
  activating a mark = temporarily "bookmark" current position,
  popping marker stack = jumping to last "bookmark). Besides the
  original behaviour (i.e beginning a region) is still available on
  =C-SPC C-SPC=.

  #+begin_src emacs-lisp :tangle core.el
    (define-minor-mode common-code-mode
      "A minor mode for enabling common minor modes and other
      features for programming modes."
      :lighter " Code"
      :keymap (let (keymap (make-sparse-keymap))
                (bind-key "C-c g" #'god-mode keymap)
                keymap)

      (if (>= emacs-major-version 26)
          (setq display-line-numbers 'on)
        (progn
          (add-hook 'common-code-mode-hook 'linum-mode)))
      (transient-mark-mode -1))

    (add-hook 'common-code-mode-hook 'flycheck-mode)
    (add-hook 'common-code-mode-hook 'company-mode)
    (add-hook 'common-code-mode-hook 'hs-minor-mode)
    (add-hook 'common-code-mode-hook 'rainbow-delimiters-mode)
    (add-hook 'common-code-mode-hook 'auto-revert-mode)
    (add-hook 'common-code-mode-hook 'smartparens-mode)
    (add-hook 'common-code-mode-hook 'subword-mode)
    (add-hook 'common-code-mode-hook 'hl-line-mode)
    (add-hook 'common-code-mode-hook 'column-number-mode)
  #+end_src

  I want to hide irrelevant minor modes from cluttering my modeline.

  #+begin_src emacs-lisp :tangle core.el
    (add-hook 'common-code-mode-hook
              (lambda ()
                (diminish 'hs-minor-mode)
                (diminish 'auto-revert-mode)
                (diminish 'subword-mode)
                (diminish 'hl-line-mode)
                (diminish 'undo-tree-mode)
                (diminish 'guide-key-mode)))

  #+end_src

  I want trailing white space to be removed automatically before saving.

  #+begin_src emacs-lisp :tangle core.el
    (add-hook 'common-code-mode-hook
              (lambda () (add-hook 'before-save-hook
                                   #'delete-trailing-whitespace)))
  #+end_src

  I want Emacs Lisp to use my fancy new minor mode.

  #+begin_src emacs-lisp :tangle core.el
    (add-hook 'emacs-lisp-mode-hook 'common-code-mode)
  #+end_src

  Install the needed packages in case they don't exists.

  #+begin_src emacs-lisp :tangle core.el
    ;; Syntax and error checker
    (use-package flycheck :ensure t)

    ;; Hide minor modes in modeline
    (use-package diminish :ensure t)

    ;; Auto completion
    (use-package company :ensure t :diminish company-mode)

    ;; Rainbow delimiters
    (use-package rainbow-delimiters :ensure t :diminish rainbow-delimiters-mode)

    ;; Relative line numbering
    (use-package linum-relative :ensure t)

    ;; Parens handling
    (use-package smartparens :ensure t :diminish smartparens-mode
      :init
      (require 'smartparens-config))

    ;; God mode
    (use-package god-mode :ensure t :diminish god-mode)
  #+end_src

* Modules
  In order to make it possible to only compile the enabled modules and
  not just making everything my module system needs to be a bit more
  clever. A possible and rather "simple" solution is to have a
  directory where all available modules reside and another directory
  where all enabled modules are and then Emacs will only read modules
  from the enabled directory. This approach is a rather common way of
  enabling and disabling stuff in other projects as well.

  However, this means that we need to have a way to configure stuff a
  bit and why not use Emacs built-in customize tool?

  #+begin_src emacs-lisp :tangle core.el
    (defgroup core nil "Core configurable options."
      :group 'emacs)

    (defcustom enabled-modules-directory (concat user-emacs-directory "modules/")
      "Where enabled modules reside, Emacs look here for modules to load."
      :type 'string
      :group 'core)

    (defcustom available-modules-directory (concat user-emacs-directory "available-modules/")
      "Where available modules reside, Emacs look here for modules to enable."
      :type 'string
      :group 'core)

    ;; Enabled modules
    (defcustom enabled-modules nil
      "The list of enabled modules.
    A module represents a subdirectory inside modules/ directory that will contain a module.el file which will be loaded by Emacs as part of the init process."
      :type '(repeat string)
      :group 'core)
  #+end_src

  Now that we have customizable directories and a list of enabled
  modules we start by symlinking the enabled modules to the enabled subdirectory.

  #+begin_src emacs-lisp :tangle core.el
    (defun enable-modules ()
      "Enable modules by symlinking them from available-modules/ to modules/."
      (dolist (module enabled-modules)
        (let ((mod-dir (concat enabled-modules-directory module))
              (src-dir (concat available-modules-directory module)))
          (unless (file-directory-p mod-dir)
            (if (file-directory-p src-dir)
                (make-symbolic-link (expand-file-name src-dir) (expand-file-name mod-dir) t)
              (warn (concat "Could not enable module " module ", make sure that it's sources are available in " available-modules-directory)))))))
  #+end_src

  Now we only need to load the modules using a superficially modified
  version of the old ~enable-modules~ function. Since we now know that
  the only modules that should be in the ~enabled-modules-directory~
  are the ones we want to load we don't need to read from the
  enabled-modules variable, but I have changed that yet.

  #+begin_src emacs-lisp :tangle core.el
    (defun load-modules ()
      "Load modules specified in ENABLED-MODULES, by loading each module.el in modules/."
      (unless (listp enabled-modules)
        (error "Customizable variable enabled-modules is not a list"))
      (dolist (module enabled-modules)
        (let ((code (concat enabled-modules-directory module "/module.el")))
          (if (file-exists-p code)
              (load code)
            (warn (concat "Could not find module file " code))))))
  #+end_src
